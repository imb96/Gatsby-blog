---
date: '2023-06-05'
title: '[Day 2] JavaScript 주요 문법 (2)'
categories: ['DevCourse', 'TIL']
summary: '프로그래머스 데브코스 TIL'
thumbnail: './til.jpg'
---
# [Day 2] JavaScript 주요 문법 (2)
> 프로그래머스 데브코스 프론트엔드 4기 과정중 몰랐던, 헷갈렸던 혹은 더 알고싶은 내용을 정리합니다. 😁
### 브라우저에 URL을 입력하면?
1. URL을 해석한다.
- `scheme://<user>:<password>@<host>:<port>/<url-path>`
- ex) https://programmers.co.kr/
1. DNS(Domain Name System) 조회를 하여 도메인을 IP주소로 변환한다.
2. 네트워크 장비 라우터를 통해 해당 IP가 존재하는 서버로 이동한다.
3. ARP(Address Resolution Protocol)를 이용하여 IP주소(논리주소) 를 MAC주소(물리 주소)로 변환 한다.
    1. 기계의 실제 위치를 알기 위해선 MAC 주소가 필요하다.
4. TCP 통신을 통해 Socket을 열어야 한다.
5. 서버는 응답을 반환한다.
6. 브라우저는 렌더링 한다.
### http와 https의 차이
- 보안: HTTP 메시지는 일반 텍스트이므로, 권한이 없어도 인터넷을 통해 접근할 수 있지만 HTTPS는 모든 데이터를 암호화된 형태로 전송한다.
- 권위: 검색 엔진은 HTTP의 신뢰성이 더 낮기 때문에 보통 HTTP 웹 사이트 콘텐츠의 순위를 HTTPS 웹 페이지보다 낮게 지정한다. (브라우저는 주소 표시줄에서 자물쇠 아이콘을 표시하여 https 연결을 표시한다.)
- 성능 및 분석: HTTPS 웹 앱은 HTTP 앱보다 로드 속도가 더 빠르며 참조 링크도 더 잘 추적한다.
### 암호화
평문을 해독할 수 없는 암호문으로 변환하는 것을 의미한다.
단방향(해싱)과 양방향 암호화가 존재한다.

**단방향 암호화**
- 한 방향으로만 이어지는 암호화
- 해시 알고리즘을 사용하여 평문을 복호화 할 수 없는 형태로 암호화한다.
**양방향 암호화**
- 평문을 복호화 할 수 없는 형태로 암호화 하는 방법
- 대표적으로 대칭키를 이용하는 AES와 비대칭키를 이용하는 RSA로 나뉜다.
### 함수형 프로그래밍
프로그램은 `순차, 분기, 반복, 참조` 로 구성된다.
패러다임은 위 4가지 요소를 어떻게 이용할 것인가를 다룬다.

**함수형 프로그래밍**
- 객체지향 추상화의 최소 단위가 객체인것처럼 함수형은 함수가 최소 단위다.
- 함수 단위로 나눠지므로 재사용성이 높다.
- 데이터의 불변성을 지향하기에 동작을 예측하기 쉽고 사이드 이펙트를 방지한다.
- 객체지향은 제어 흐름의 간접적인 전환에 부과되는 규율
- 함수형은 변수 할당에 부과되는 규율
**선언형 프로그래밍**
- 명령형 프로그래밍은 `문제를 어떻게 해결해야 하는지` 컴퓨터에게 명령을 내리는 방법
- 선언형 프로그래밍은 `무엇을 해결해야 할지` 에 집중하고 해결방법은 컴퓨터에게 위임하는 방법
자바스크립트는 멀티 패러다임이 가능하다. 굳이 객체지향과 함수형 으로 나눌 필요는 없다! 
### 객체지향과 프로토타입
**객체지향**
- 객체 위주로 설계하고 프로그래밍하는 패러다임
- 객체지향 언어에선 추상화의 최소 단위가 객체다.
- 각각의 객체는 메시지를 주고받을 수 있다.
객체지향의 객체는 `현실` 에 있는 것을 `추상화` 한 것.
추상이란 사물이 지니고 있는 여러 측면 중 `특정 부분` 을 추출하는 것.
JavaScript는 프로토타입을 통해 객체지향을 표현한다.

**프로토타입**
기존의 객체를 복사하여 새로운 객체를 생성하는 방식
### 이벤트루프
JavaScript는 `Single Thread`로 동작한다 → JS엔진의 Call Stack은 하나만 존재한다.

그런데 브라우저에서 실행되는 스크립트는 어떻게 비동기적으로 실행될까? → `이벤트 루프`가 있기때문.

이벤트루프는 자바스크립트의 기능이 아닌 브라우저나 Node에서 관리된다.

비동기 작업은 `Task Queue` 뿐만 아니라 `Microtask Queue`, `Animation frames`에도 등록된다.

이벤트 루프가 비동기 작업을 처리하는 우선순위는 Microtask Queue → Animation Frames → Task Queue 순이다.

이벤트 루프는 Microtask Queue나 Animation Frames를 방문할 때는 큐 안에 있는 모든 작업들을 수행하지만, Task Queue를 방문할 때는 한 번에 하나의 작업만 Call Stack으로 전달하고 다른 Queue를 순회한다.
### 모듈
모듈과 컴포넌트는 자주 혼용되는데 모듈은 설계 시점에서 의미있는 요소이고 컴포넌트는 런타임 시점에 의미있는 요소다.

import와 export를 통해 모듈 불러오기와 내보내기를 수행할 수 있다.

모듈은 로컬 파일에서 동작하지 않고 HTTP/HTTPS 프로토콜을 통해서만 동작한다.

**모듈의 특징**
1. 항상 use strict로 실행된다.
2. 모듈 레벨 스코프가 있다.
3. 단 한 번만 평가된다.
4. 지연 실행된다.
Webpack 등을 이용하여 번들링한 스크립트를 불러오면 크게 type=”module”을 사용할 일이 별로 없다.
### 유니코드
대부분의 문자를 포함하여 이모티콘도 포함되어 있다.
전 세계 문자를 컴퓨터에서 다룰 수 있도록 만든 표준 시스템을 만들었다.
### 정규표현식
정규표현식의 목적
- 패턴을 이용하여 문자 검색 (search)
- 패턴을 이용하여 문자 대체 (replace)
- 패턴을 이용하여 문자 추출 (extract)
성능은 느리지만 편하다!
JavaScript는 RegExp 객체로 정규표현식 기능을 제공한다.
Array, Object 처럼 Literal로 생성 가능하다.

정규표현식 객체의 함수
- test: 입력받은 문자열에 찾는 패턴이 있는지 찾은 후 있으면 true, 없으면 false를 반환한다.
- exec: 일치한 패턴 정보를 반환하고 없으면 null을 반환한다.
- capture: match 반환값의 1번 인덱스 부터 순차적으로 캡처 결과가 들어간다.
String 객체의 함수
- match :  exec 함수와 같다. matchAll함수는 매칭된 모든 케이스를 반환한다.
- replace: 일치한 패턴 정보를 원하는 문자열로 바꿀 수 있다.
- search: 일치한 패턴 정보의 위치를 반환한다.
### 쿠키와 세션, 웹 스토리지
**Cookie**
- 클라이언트에서 저장, 관리하는 데이터들. 브라우저를 닫아도 데이터를 유지할 수 있다.
- 서버에서 Set-Cookie를 응답 헤더로 내려주면 클라이언트는 받아서 저장한다.
- 클라이언트에서 자체적으로 조작할 수 있다.
- 각 상태에 수명을 정할 수 있다.
**Set-Cookie**
- Set-Cookie:키=값;옵션
- 응답 헤더에 담으면 브라우저가 알아서 저장한다.
- 각 데이터의 옵션
    - Expires: 쿠키 만료 날짜를 지정한다.
    - Secure: HTTPS에서만 쿠키를 전송한다.
    - HttpOnly: JavaScript에서 쿠키에 접근 못하도록 막는다.
    - Max-Age: 쿠키 수명을 정한다. 이떄 Expires는 무시된다.
    - Domain: 도메인이 일치하는 요청만 쿠키가 전송된다.
    - Path: 패스와 일치하는 요청만 쿠키가 전송된다.
**쿠키의 취약점**
- XSS(Cross-Site Script)공격을 당할 수 있다.
    - JavaScript를 이용해 악의적인 사용자가 다른 사용자의 쿠키값을 탈취 할 수 있다.
    - 쿠키를 암호화 하지 않고 보내면 쿠키값을 중간에 탈취 당할 가능성이 있다.
**Session**
- HTTP Session id를 식별자로 사용자를 구분한다.
- 클라이언트는 HTTP Session id를 쿠키 형태로 저장한다.
- 서버 자체적으로 기록하고 관리한다.
이제 서버와 클라이언트간 인증은 JWT와 같은 `별도 토큰` 을 사용하고 쿠키는 클라이언트 자체적인 `지속적인 데이터 관리 용도` 로 많이 사용된다.
### 웹 스토리지
클라이언트에 데이터를 저장하기 위한 새로운 방법으로, 쿠키에서 하기 힘든 것들을 지원한다.

**로컬 스토리지**
- 데이터를 저장하면 반영구적으로 데이터가 저장된다.
- 브라우저를 종료해도 데이터가 남는다.
- 저장했던 도메인과 이용하는 도메인이 다른 경우엔 접근할 수 없다.
- 쿠키와 마찬가지로 key-value 형태로 저장한다.
**세션 스토리지**
- 새 창을 생성할 때마다 개별적으로 저장되는 데이터를 관리한다
- 브라우저를 닫는 순간 사라진다.
- 같은 도메인이어도 세션이 다르면 데이터에 접근할 수 없다.
- 쿠키와 마찬가지로 key-value 형태로 저장한다.
```js
// 쿠키 관리는 String으로 한다.
document.cookie = "key=value; key2=value2";

// 데이터 저장
localStorage.setItem('name', '김민재');
console.log(localStorage.getItem('name')); // 김민재

// 데이터 삭제
localStorage.removeItem('name');
// 데이터 전부 삭제
localStorage.clear();

// 데이터 저장
sessionStorage.setItem('name', '김민재');
console.log(sessionStorage.getItem('name')); // 김민재

// 데이터 삭제
sessionStorage.removeItem('name');
// 데이터 전부 삭제
sessionStorage.clear();
```

> ps. 블로그에 TIL을 작성하고 링크를 공유하다가 오류(?)를 발견했다. https://imb96.github.io/DevCourse_2/ 이런식으로 포스팅글을 공유하면 뒤로가기 버튼을 누르게되면 작동을 하지 않는 일이 발생했다. 그래서 뒤로가기 버튼 onCLick 이벤트 로직을 변경했다. 기존 history API로 구현한 `const goBackPage = () => window.history.back()` 부분을 `const goBackPage = () => window.location.href = "../"` 이렇게 바꾸었더니 잘 동작한다!👍