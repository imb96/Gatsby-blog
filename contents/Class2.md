---
date: '2022-08-26'
title: 'Class'
categories: ['JS']
summary: '자바스크립트 완벽가이드 클래스'
thumbnail: './jsperfectguide.png'
---
> 자바스크립트 완벽가이드를 읽고 정리한 내용입니다.
# 클래스
자바스크립트의 객체는 프로퍼티의 고유한 집합이며 다른 어떤 객체와도 같지 않다. 하지만 일부 프로퍼티를 공유하는 객체 클래스를 만드는 것이 유용할 때도 많다. 클래스의 인스턴스는 자신의 상태를 정의하는 자체 프로퍼티도 갖지만, 자신의 동작을 정의하는 메서드도 가진다. 이런 메서드는 클래스에서 정의하며 모든 인스턴스에서 공유한다. 
자바스크립트 클래스는 프로토타입 기반 상속을 사용한다. 두 객체가 같은 프로토타입에서 프로퍼티(일반적으로 함수 값인 프로퍼티나 메서드)를 상속한다면 이들을 같은 클래스의 인스턴스라고 부른다.
## 클래스와 프로토타입
자바스크립트에서 클래스는 같은 프로토타입 객체에서 프로퍼티를 상속하는 객체 집합이다. 따라서 프로토타입 객체가 클래스의 핵심 기능이다. 프로토타입 객체를 정의하고 Object.create()로 프로토타입을 상속하는 객체를 생성한다면 자바스크립트 클래스를 정의한 것이다. 보통 클래스 인스턴스는 초기화가 더 필요하므로 새 객체를 생성하고 초기화하는 함수를 정의하는 것이 일반적이다. 다음 예제는 일정 범위의 값을 나타내는 클래스의 프로토타입 객체를 정의하고, 클래스의 인스턴스를 생성하고 초기화하는 **팩토리함수** 역시 정의한다.
```javascript
// Range 객체를 반환하는 팩토리 함수
function range(from, to) {
  // Object.create()를 써서 아래에서 정의하는 프로토타입 객체를 상속하는
  // 객체를 생성한다. 프로토타입 객체는 이 함수의 프로퍼티로 저장되며
  // Range 객체에서 공유하는 메서드(동작)를 정의한다.
  let r = Object.create(range.methods);

  // Range 객체의 시작점과 끝점(상태)을 저장한다.
  // 이들은 이 객체에 고유한 프로퍼티이며 상속되지 않는다.
  r.from = from;
  r.to = to;
  // 마지막으로 새 객체를 반환한다.
  return r;
}
// 이 프로토타입 객체는 Range 객체가 상속하는 메서드를 정의한다.
range.methods = {
  // x가 이 범위 안에 있으면 true, 없으면 false를 반환.
  // 이 메서드는 숫자뿐만 아니라 텍스트, 날짜 범위에도 동작한다.
  includes(x) { return this.from <= x && x <= this.to; },

  // 클래스 인스턴스를 이터러블로 만드는 제네레이터 함수이다.
  // 이 기능은 숫자 범위에서만 동작한다.
  *[Symbol.iterator]() {
    for(let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  },

  // 범위를 나타내는 문자열을 반환한다.
  toString() { return "(" + this.from + "..." + this.to + ")"; }
};

// Range 객체의 사용 예제
let r = range(1,3); // Range 객체 생성
r.includes(2) // => true: 2는 범위 안에 있다.
r.toString()  // => "(1...3)"
[...r]  // => [1,2,3]; 이터레이터 를 통해 배열로 반환한다.
```
위 예제는 자바스크립트 클래스를 정의하는 단순한 방법이지만 생성자를 정의하지 않았기 때문에 널리 쓰이는 방법은 아니다. 생성자는 새로 생성된 객체를 초기화하도록 설계된 함수이다. 생성자는 new 키워드를 사용해 생성하며 new 를 사용해 생성자를 호출하면 자동으로 새 객체가 생성되므로, 생성자 자체에서 할 일은 새 객체의 상태를 초기화하는 것 뿐이다. 생성자 호출에서 중요한 특징은 생성자의 prototype 프로퍼티가 새 객체의 프로토타입으로 사용된다는 것이다.
> 생성자와 new.target
> 함수 바디 안에서 특별한 포현식 new.target을 사용하면 함수가 생성자로 호출됐는지 알 수 있다. 이 표현식의 값이 undefined가 아니면 그 함수는 new 키워드와 함께 생성자로 호출된 것이다. new.target이 항상 생성자를 참조하는 것은 아니며, 서브클래스의 생성자 함수를 참조할 수도 있다. new.target이 undefined 라면 이 함수는 new 키워드 없이 함수로 호출된 것이다. 자바스크립트의 에러 생성자는 new 없이 호출될 수 있다.
```js
function C() {
  if (!new.target) return new C();
  // 초기화 코드
}
```
> 이 기법은 오래된 방법으로 정의된 생성자에서만 동작한다. class 키워드로 생성된 클래스는 new없이 생성자를 호출할 수 없다.
### 생성자, 클래스의 본질, instanceof
프로토타입 객체는 클래스의 본질이다. 두 객체가 같은 프로토타입 객체를 상속하지 않는다면 같은 클래스의 인스턴스가 아니다. 생성자 함수는 그렇지 않다. 서로 다른 생성자 함수의 prototype 프로퍼티가 같은 프로토타입 객체를 참조할 수도 있다. 그리고 두 생성자가 같은 클래스의 인스턴스를 초기화할 수 있다.
객체 r이 Range 객체인지 확인하고 싶을 때는 다음과 같은 코드를 사용한다.
```javascript
r instanceof Range // => true: r은 Range.prototype을 상속한다.
```
객체의 프로토타입 체인에 특정 프로토타입이 존재하는지 테스트하고 싶지만 생성자 함수를 기준으로 하지 않으려면 isPrototype()메서드를 사용한다.
### 생성자 프로퍼티
일반적인 자바스크립트 함수는 모두 자동으로 prototype 프로퍼티를 갖는다.(Function.bind()메서드에서 반환하는 함수는 제외) 이 프로퍼티의 값은 열거 불가인 constructor 프로퍼티 단 하나이다. constructor 프로퍼티의 값은 함수 객체이다.
```js
let F = function() {};  // 함수 객체
let p = F.prototype;    // F 에 연결된 프로토타입 객체
let c = p.constructor;  // 프로토타입에 연결된 함수
c === F                 // true: 모든 F에 대해 F.prototype.constructor === F
```
constructor 프로퍼티를 가진 미리 정의된 프로토타입 객체가 존재한다는 것은, 그 객체가 일반적으로 자신의 생성자를 참조하는 constructor 프로퍼티를 상속한다는 의미다. 생성자는 클래스의 공개된 부분을 담당하므로 이 생성자 프로퍼티가 객체에 클래스를 부여한다.
```js
let o = new F();    //클래스 F의 객체 o생성
o.constructor === F; // true: 생성자 프로퍼티가 클래스를 지정한다.
```
## class 키워드를 상요하는 클래스
```js
class Range {
  constructor(from, to) {
    // Range 객체의 시작점과 끝점(상태)을 저장한다.
    // 이들은 이 객체에 고유한 프로퍼티이며 상속되지 않는다.
    this.from = from;
    this.to = to;
  }
  // x가 범위 안에 있으면 true를, 그렇지 않다면 false를 반환한다.
  // 이 메서드는 숫자뿐만 아니라 텍스트, 날짜 범위에도 동작한다.
  includes(x) {return this.from <= x && x < = this.to;}
  // 클래스 인스턴스를 이터러블로 만드는 제너레이터 함수
  // 이 기능은 숫자 범위에서만 동작한다.
  *[Symbol.iterator](){
    for(let x = Math.ceil(this.from); x <= this.to; x++) yield x;
  }
  // 범위를 나타내는 문자열을 반환
  toString() { return `(${this.from}...${this.to})`;}
}
// Range 클래스는 다음과 같이 사용합니다.
let r = new Range(1,3); // Range 객체를 생성한다.
r.includes(2)           // true: 2는 범위 안에 있다.
r.toString()            // "(1...3)"
[...r]                  // [1,2,3]; 이터레이터를 통해 배열로 변환.
```
